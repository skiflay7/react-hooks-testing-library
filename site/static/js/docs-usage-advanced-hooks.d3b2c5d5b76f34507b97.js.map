{"version":3,"sources":["/Users/mxp001/programming/frontend/libraries/react-hooks-testing-library/docs/usage/advanced-hooks.md"],"names":["_react2","_interopRequireDefault","__webpack_require__","layoutProps","MDXLayout","MDXContent","_ref","components","props","_objectWithoutProperties2","default","mdx","_extends2","mdxType","id","parentName","href","className","isMDXComponent"],"mappings":"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","file":"static/js/docs-usage-advanced-hooks.c946c790.js","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"advanced-hooks\"\n    }}>{`Advanced Hooks`}</h1>\n    <h2 {...{\n      \"id\": \"providing-props\"\n    }}>{`Providing Props`}</h2>\n    <p>{`Sometimes a hook relies on the props passed to it in order to do it's thing. For example the `}<inlineCode parentName=\"p\">{`useCounter`}</inlineCode>{` hook we built in the `}<a parentName=\"p\" {...{\n        \"href\": \"/usage/basic-hooks\"\n      }}>{`Basic Hooks`}</a>{` section could easily accept the initial value of the counter:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { useState, useCallback } from 'react'\n\nexport default function useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue)\n  const increment = useCallback(() => setCount(count + 1), [count])\n  return { count, increment }\n}\n`}</code></pre>\n    <p>{`Overriding the `}<inlineCode parentName=\"p\">{`initialValue`}</inlineCode>{` prop in out test is as easy as calling the hook with the value we want to use:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { renderHook, act } from 'react-hooks-testing-library'\nimport useCounter from './useCounter'\n\ntest('should increment counter from custom initial value', () => {\n  const { result } = renderHook(() => useCounter(9000))\n\n  act(() => {\n    result.current.increment()\n  })\n\n  expect(result.current.count).toBe(9001)\n})\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"changing-props\"\n    }}>{`Changing Props`}</h3>\n    <p>{`Many of the hook primitives use an array of dependent values to determine when to perform specific actions, such as recalculating an expensive value or running an effect. If we update our `}<inlineCode parentName=\"p\">{`useCounter`}</inlineCode>{` hook to have a `}<inlineCode parentName=\"p\">{`reset`}</inlineCode>{` function that resets the value to the `}<inlineCode parentName=\"p\">{`initialValue`}</inlineCode>{` it might look something like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { useState, useCallback } from 'react'\n\nexport default function useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue)\n  const increment = useCallback(() => setCount(count + 1), [count])\n  const reset = useCallback(() => setCount(initialValue), [initialValue])\n  return { count, increment, reset }\n}\n`}</code></pre>\n    <p>{`Now, the only time the `}<inlineCode parentName=\"p\">{`reset`}</inlineCode>{` function will be updated is if `}<inlineCode parentName=\"p\">{`initialValue`}</inlineCode>{` changes. The most basic way to handle changing the input props of our hook in a test is to simply update the value in a variable and rerender the hook:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { renderHook, act } from 'react-hooks-testing-library'\nimport useCounter from './useCounter'\n\ntest('should reset counter to updated initial value', () => {\n  let initialValue = 0\n  const { result, rerender } = renderHook(() => useCounter(initialValue))\n\n  initialValue = 10\n  rerender()\n\n  act(() => {\n    result.current.reset()\n  })\n\n  expect(result.current.count).toBe(10)\n})\n`}</code></pre>\n    <p>{`This is fine, but if there are lots of props, it can become a bit difficult to have variables to keep track of them all. Another option is to use the `}<inlineCode parentName=\"p\">{`initialProps`}</inlineCode>{` option and `}<inlineCode parentName=\"p\">{`newProps`}</inlineCode>{` of `}<inlineCode parentName=\"p\">{`rerender`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { renderHook, act } from 'react-hooks-testing-library'\nimport useCounter from './useCounter'\n\ntest('should reset counter to updated initial value', () => {\n  const { result, rerender } = renderHook(({ initialValue }) => useCounter(initialValue), {\n    initialProps: { initialValue: 0 }\n  })\n\n  rerender({ initialValue: 10 })\n\n  act(() => {\n    result.current.reset()\n  })\n\n  expect(result.current.count).toBe(10)\n})\n`}</code></pre>\n    <p>{`Another case where this is useful is when you want limit the scope of the variables being closed over to just be inside the hook callback. The following (contrived) example fails because the `}<inlineCode parentName=\"p\">{`id`}</inlineCode>{` value changes for both the setup and cleanup of the `}<inlineCode parentName=\"p\">{`useEffect`}</inlineCode>{` call:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { useEffect } from 'react'\nimport { renderHook } from \"react-hooks-testing-library\"\nimport sideEffect from './sideEffect\n\ntest(\"should clean up side effect\", () => {\n  let id = \"first\"\n  const { rerender } = renderHook(() => {\n    useEffect(() => {\n      sideEffect.start(id)\n      return () => {\n        sideEffect.stop(id) // this id will get the new value when the effect is cleaned up\n      }\n    }, [id])\n  })\n\n  id = \"second\"\n  rerender()\n\n  expect(sideEffect.get(\"first\")).toBe(false)\n  expect(sideEffect.get(\"second\")).toBe(true)\n})\n`}</code></pre>\n    <p>{`By using the `}<inlineCode parentName=\"p\">{`initialProps`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`newProps`}</inlineCode>{` the captured `}<inlineCode parentName=\"p\">{`id`}</inlineCode>{` value from the first render is used to clean up the effect, allowing the test to pass as expected:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { useEffect } from 'react'\nimport { renderHook } from \"react-hooks-testing-library\"\nimport sideEffect from './sideEffect\n\ntest(\"should clean up side effect\", () => {\n  const { rerender } = renderHook(\n    ({ id }) => {\n      useEffect(() => {\n      sideEffect.start(id)\n      return () => {\n        sideEffect.stop(id) // this id will get the new value when the effect is cleaned up\n      }\n    }, [id])\n    },\n    {\n      initialProps: { id: \"first\" }\n    }\n  )\n\n  rerender({ id: \"second\" })\n\n  expect(thing.get(\"first\")).toBe(false)\n  expect(thing.get(\"second\")).toBe(true)\n})\n`}</code></pre>\n    <p>{`This is a fairly obscure case, so pick the method that fits best for you and your test.`}</p>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "],"sourceRoot":""}